ğŸ”¹  What is CI/CD?

CI (Continuous Integration): Automatically builds and tests code whenever changes are pushed.
CD (Continuous Deployment/Delivery): Automatically deploys code to servers/cloud after passing tests.

Think of it like:
ğŸ‘‰ You push code â†’ GitHub Actions/Jenkins picks it up â†’ runs checks â†’ if all good â†’ deploys.

Git is a distributed version control system (VCS).
Use: It helps you track changes in your code, go back in history
Runs in you local machine(CLI)

GitHub/GitLab = platforms to host/manage repositories and collaborate with others
GitLab = same as GitHub, but with strong built-in CI/CD.

GitHub Actions / GitLab CI / Jenkins = CI/CD built in automation tools.
Automates workflows (build, test, deploy).
Works on their own server.

ğŸ”¹ What is a Pipeline?

A pipeline = series of automated steps (stages) your code goes through.

Example stages:
Build â†’ compile code, install dependencies.
Test â†’ run unit tests, check quality.
Deploy â†’ push app to server/cloud.

GitHub Actions basics

Simple GitHub Actions Workflow

mkdir -p .github/workflows           // =p makes parent directories as needed, With -p:Creates .github if it doesnâ€™t exist, then creates workflows inside it.
nano .github/workflows/hello.yml

Paste this inside:
yaml
-----------------------

name: Hello World Workflow                   //name of the workflow

on: [push]                                   //Defines the event that triggers the workflow

jobs:                                        //A workflow can have multiple jobs, each can run independently or sequentially
  build:                                     //Name of the job
    runs-on: ubuntu-latest                   //The runner (virtual machine) where this job will run.
    steps:                                   //Individual steps inside a job.              
      - name: Checkout code
        uses: actions/checkout@v3            //prebuilt action that pulls your repo code into the runner.
                                             //Without this, your workflow wouldnâ€™t have access to your repository files.

      - name: Run Hello World
        run: echo "Hello, World! ğŸ‰"        //Execute a shell command in the runner.

-----------------------

Commit and push:

git add .github/workflows/hello.yml
git commit -m "added hello world workflow"
git push origin main

Trigger: any push to the repo.
Runs one job (build) on a Linux runner.
Steps in job:
Checkout repo code.
Print â€œHello Worldâ€ message.
Result: You see the workflow run automatically in GitHub Actions whenever you push.

You just created your first CI/CD pipeline


Automating Tests & Builds your code on every pull request (PR)
 Ensures code quality before merging into main.
Example workflow stages:
Checkout code
Install dependencies
Run tests/lint
Build app
Save build artifacts (optional)

Create a file: .github/workflows/pr-tests.yml

name: PR Test & Build

# Trigger workflow on pull request to main
on:
  pull_request:
    branches:
      - main

jobs:
  test-build:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v3

      - name: Setup Node.js
        uses: actions/setup-node@v3
        with:
          node-version: '18'

      - name: Install dependencies
        run: npm install

      - name: Run tests
        run: npm test

      - name: Run build
        run: npm run build

      - name: Upload build artifacts
        uses: actions/upload-artifact@v3
        with:
          name: build-output
          path: build/


End-to-end CI/CD Flow (Git + GitHub Actions)

Git workflow:
Create branch â†’ commit â†’ push â†’ PR â†’ merge â†’ main

CI/CD workflow:
Trigger workflow on push/PR
Run tests â†’ build â†’ deploy automatically
Optionally save artifacts or notify team

Outcome:
Code is automatically verified, packaged, and deployed
Reduces human error, speeds up delivery


Automated deployment is better because:

   Reduces human error
   Faster, repeatable, reliable
   Can roll back easily
